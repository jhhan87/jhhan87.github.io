/*!
 * jekyll-theme-chirpy v7.3.1 | Â© 2019 Cotes Chung | MIT Licensed | https://github.com/cotes2020/jekyll-theme-chirpy/
 */
var Theme = (function () {
  'use strict';

  function _assertClassBrand(e, t, n) {
    if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
    throw new TypeError("Private element is not present on this object");
  }
  function _classPrivateGetter(s, r, a) {
    return a(_assertClassBrand(s, r));
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t, e;
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r);
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }

  var _Theme;
  /**
   * Theme management class
   *
   * To reduce flickering during page load, this script should be loaded synchronously.
   */
  class Theme {
    static get DARK() {
      return 'dark';
    }
    static get LIGHT() {
      return 'light';
    }

    /**
     * @returns {string} Theme mode identifier
     */
    static get ID() {
      return 'theme-mode';
    }

    /**
     * Gets the current visual state of the theme.
     *
     * @returns {string} The current visual state, either the mode if it exists,
     *                   or the system dark mode state ('dark' or 'light').
     */
    static get visualState() {
      if (_classPrivateGetter(Theme, this, _get_hasMode)) {
        return _classPrivateGetter(Theme, this, _get_mode);
      } else {
        return _classPrivateGetter(Theme, this, _get_sysDark) ? this.DARK : this.LIGHT;
      }
    }
    /**
     * Maps theme modes to provided values
     * @param {string} light Value for light mode
     * @param {string} dark Value for dark mode
     * @returns {Object} Mapped values
     */
    static getThemeMapper(light, dark) {
      return {
        [this.LIGHT]: light,
        [this.DARK]: dark
      };
    }

    /**
     * Initializes the theme based on system preferences or stored mode
     */
    static init() {
      if (!this.switchable) {
        return;
      }
      _assertClassBrand(Theme, this, _darkMedia)._.addEventListener('change', () => {
        const lastMode = _classPrivateGetter(Theme, this, _get_mode);
        _assertClassBrand(Theme, this, _clearMode).call(this);
        if (lastMode !== this.visualState) {
          _assertClassBrand(Theme, this, _notify).call(this);
        }
      });
      if (!_classPrivateGetter(Theme, this, _get_hasMode)) {
        return;
      }
      if (_classPrivateGetter(Theme, this, _get_isDarkMode)) {
        _assertClassBrand(Theme, this, _setDark).call(this);
      } else {
        _assertClassBrand(Theme, this, _setLight).call(this);
      }
    }

    /**
     * Flips the current theme mode
     */
    static flip() {
      if (_classPrivateGetter(Theme, this, _get_hasMode)) {
        _assertClassBrand(Theme, this, _clearMode).call(this);
      } else {
        _classPrivateGetter(Theme, this, _get_sysDark) ? _assertClassBrand(Theme, this, _setLight).call(this) : _assertClassBrand(Theme, this, _setDark).call(this);
      }
      _assertClassBrand(Theme, this, _notify).call(this);
    }
  }
  _Theme = Theme;
  function _get_mode(_this) {
    return sessionStorage.getItem(_assertClassBrand(_Theme, _this, _modeKey)._) || document.documentElement.getAttribute(_assertClassBrand(_Theme, _this, _modeAttr)._);
  }
  function _get_isDarkMode(_this2) {
    return _classPrivateGetter(_Theme, _this2, _get_mode) === _this2.DARK;
  }
  function _get_hasMode(_this3) {
    return _classPrivateGetter(_Theme, _this3, _get_mode) !== null;
  }
  function _get_sysDark(_this4) {
    return _assertClassBrand(_Theme, _this4, _darkMedia)._.matches;
  }
  function _setDark() {
    document.documentElement.setAttribute(_assertClassBrand(_Theme, this, _modeAttr)._, this.DARK);
    sessionStorage.setItem(_assertClassBrand(_Theme, this, _modeKey)._, this.DARK);
  }
  function _setLight() {
    document.documentElement.setAttribute(_assertClassBrand(_Theme, this, _modeAttr)._, this.LIGHT);
    sessionStorage.setItem(_assertClassBrand(_Theme, this, _modeKey)._, this.LIGHT);
  }
  function _clearMode() {
    document.documentElement.removeAttribute(_assertClassBrand(_Theme, this, _modeAttr)._);
    sessionStorage.removeItem(_assertClassBrand(_Theme, this, _modeKey)._);
  }
  /**
   * Notifies other plugins that the theme mode has changed
   */
  function _notify() {
    window.postMessage({
      id: this.ID
    }, '*');
  }
  var _modeKey = {
    _: 'mode'
  };
  var _modeAttr = {
    _: 'data-mode'
  };
  var _darkMedia = {
    _: window.matchMedia('(prefers-color-scheme: dark)')
  };
  _defineProperty(Theme, "switchable", !document.documentElement.hasAttribute(_assertClassBrand(_Theme, _Theme, _modeAttr)._));
  Theme.init();

  return Theme;

})();
//# sourceMappingURL=theme.min.js.map
